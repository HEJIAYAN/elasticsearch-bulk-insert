<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ElasticSearchBulk.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">PDI Elasticsearch Bulk Insert Plugin Core</a> &gt; <a href="index.source.html" class="el_package">org.pentaho.di.trans.steps.elasticsearchbulk</a> &gt; <span class="el_source">ElasticSearchBulk.java</span></div><h1>ElasticSearchBulk.java</h1><pre class="source lang-java linenums">/*! ******************************************************************************
 *
 * Pentaho Data Integration
 *
 * Copyright (C) 2002-2017 by Hitachi Vantara : http://www.pentaho.com
 *
 *******************************************************************************
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 ******************************************************************************/

package org.pentaho.di.trans.steps.elasticsearchbulk;

import java.io.IOException;
import java.net.UnknownHostException;
import java.util.*;
import java.util.concurrent.TimeUnit;

import org.apache.commons.lang.StringUtils;
import org.apache.http.HttpHost;
import org.elasticsearch.action.ListenableActionFuture;
import org.elasticsearch.action.bulk.BulkRequest;
import org.elasticsearch.action.bulk.BulkResponse;
import org.elasticsearch.action.index.IndexRequest;
import org.elasticsearch.action.index.IndexResponse;
import org.elasticsearch.client.RestClient;
import org.elasticsearch.client.RestHighLevelClient;
import org.elasticsearch.common.xcontent.XContentType;
import org.pentaho.di.core.exception.KettleException;
import org.pentaho.di.core.exception.KettleStepException;
import org.pentaho.di.core.row.RowDataUtil;
import org.pentaho.di.core.row.RowMetaInterface;
import org.pentaho.di.core.row.ValueMetaInterface;
import org.pentaho.di.i18n.BaseMessages;
import org.pentaho.di.trans.Trans;
import org.pentaho.di.trans.TransMeta;
import org.pentaho.di.trans.step.BaseStep;
import org.pentaho.di.trans.step.StepDataInterface;
import org.pentaho.di.trans.step.StepInterface;
import org.pentaho.di.trans.step.StepMeta;
import org.pentaho.di.trans.step.StepMetaInterface;

/**
 * Does bulk insert of data into ElasticSearch
 *
 * @author webdetails
 * @since 16-02-2011
 */
public class ElasticSearchBulk extends BaseStep implements StepInterface {

<span class="nc" id="L62">  private static final String INSERT_ERROR_CODE = null;</span>
<span class="nc" id="L63">  private static Class&lt;?&gt; PKG = ElasticSearchBulkMeta.class; // for i18n</span>

  private ElasticSearchBulkMeta meta;
  private ElasticSearchBulkData data;

<span class="nc" id="L68">  private RestHighLevelClient client = null;</span>

  private String index;
  private String type;

<span class="nc" id="L73">  private int batchSize = 2;</span>

<span class="nc" id="L75">  private boolean isJsonInsert = false;</span>
<span class="nc" id="L76">  private int jsonFieldIdx = 0;</span>

<span class="nc" id="L78">  private String idOutFieldName = null;</span>
<span class="nc" id="L79">  private Integer idFieldIndex = null;</span>

<span class="nc" id="L81">  private Long timeout = null;</span>
<span class="nc" id="L82">  private TimeUnit timeoutUnit = TimeUnit.MILLISECONDS;</span>

  // private long duration = 0L;
<span class="nc" id="L85">  private int numberOfErrors = 0;</span>

<span class="nc" id="L87">  private boolean stopOnError = true;</span>
<span class="nc" id="L88">  private boolean useOutput = true;</span>

  private Map&lt;String, String&gt; columnsToJson;
  private boolean hasFields;

  private BulkRequest currentRequest;

  public ElasticSearchBulk( StepMeta stepMeta, StepDataInterface stepDataInterface, int copyNr, TransMeta transMeta,
      Trans trans ) {
<span class="nc" id="L97">    super( stepMeta, stepDataInterface, copyNr, transMeta, trans );</span>
<span class="nc" id="L98">    currentRequest = new BulkRequest();</span>
<span class="nc" id="L99">  }</span>

  public boolean processRow( StepMetaInterface smi, StepDataInterface sdi ) throws KettleException {

<span class="nc" id="L103">    Object[] rowData = getRow();</span>
<span class="nc bnc" id="L104" title="All 2 branches missed.">    if ( rowData == null ) {</span>
<span class="nc bnc" id="L105" title="All 2 branches missed.">      if ( currentRequest.numberOfActions() &gt; 0 ) {</span>
        // didn't fill a whole batch
<span class="nc" id="L107">        processBatch( false );</span>
      }
<span class="nc" id="L109">      setOutputDone();</span>
<span class="nc" id="L110">      return false;</span>
    }

<span class="nc bnc" id="L113" title="All 2 branches missed.">    if ( first ) {</span>
<span class="nc" id="L114">      first = false;</span>
<span class="nc" id="L115">      setupData();</span>
<span class="nc" id="L116">      initFieldIndexes();</span>
    }

    try {
<span class="nc" id="L120">      data.inputRowBuffer[data.nextBufferRowIdx++] = rowData;</span>
<span class="nc bnc" id="L121" title="All 4 branches missed.">      return indexRow( data.inputRowMeta, rowData ) || !stopOnError;</span>
<span class="nc" id="L122">    } catch ( KettleStepException e ) {</span>
<span class="nc" id="L123">      throw e;</span>
<span class="nc" id="L124">    } catch ( Exception e ) {</span>
<span class="nc" id="L125">      String msg = BaseMessages.getString( PKG, &quot;ElasticSearchBulk.Log.Exception&quot;, e.getLocalizedMessage() );</span>
<span class="nc" id="L126">      logError( msg );</span>
<span class="nc" id="L127">      throw new KettleStepException( msg, e );</span>
    }
  }

  /**
   * Initialize &lt;code&gt;this.data&lt;/code&gt;
   *
   * @throws KettleStepException
   */
  private void setupData() throws KettleStepException {
<span class="nc" id="L137">    data.nextBufferRowIdx = 0;</span>
<span class="nc" id="L138">    data.inputRowMeta = getInputRowMeta().clone(); // only available after first getRow();</span>
<span class="nc" id="L139">    data.inputRowBuffer = new Object[batchSize][];</span>
<span class="nc" id="L140">    data.outputRowMeta = data.inputRowMeta.clone();</span>
<span class="nc" id="L141">    meta.getFields( data.outputRowMeta, getStepname(), null, null, this, repository, metaStore );</span>
<span class="nc" id="L142">  }</span>

  private void initFieldIndexes() throws KettleStepException {
<span class="nc bnc" id="L145" title="All 2 branches missed.">    if ( isJsonInsert ) {</span>
<span class="nc" id="L146">      Integer idx = getFieldIdx( data.inputRowMeta, environmentSubstitute( meta.getJsonField() ) );</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">      if ( idx != null ) {</span>
<span class="nc" id="L148">        jsonFieldIdx = idx.intValue();</span>
      } else {
<span class="nc" id="L150">        throw new KettleStepException( BaseMessages.getString( PKG, &quot;ElasticSearchBulk.Error.NoJsonField&quot; ) );</span>
      }
    }

<span class="nc" id="L154">    idOutFieldName = environmentSubstitute( meta.getIdOutField() );</span>

<span class="nc bnc" id="L156" title="All 2 branches missed.">    if ( StringUtils.isNotBlank( meta.getIdInField() ) ) {</span>
<span class="nc" id="L157">      idFieldIndex = getFieldIdx( data.inputRowMeta, environmentSubstitute( meta.getIdInField() ) );</span>
<span class="nc bnc" id="L158" title="All 2 branches missed.">      if ( idFieldIndex == null ) {</span>
<span class="nc" id="L159">        throw new KettleStepException( BaseMessages.getString( PKG, &quot;ElasticSearchBulk.Error.InvalidIdField&quot; ) );</span>
      }
    } else {
<span class="nc" id="L162">      idFieldIndex = null;</span>
    }
<span class="nc" id="L164">  }</span>

  private static Integer getFieldIdx( RowMetaInterface rowMeta, String fieldName ) {
<span class="nc bnc" id="L167" title="All 2 branches missed.">    if ( fieldName == null ) {</span>
<span class="nc" id="L168">      return null;</span>
    }

<span class="nc bnc" id="L171" title="All 2 branches missed.">    for ( int i = 0; i &lt; rowMeta.size(); i++ ) {</span>
<span class="nc" id="L172">      String name = rowMeta.getValueMeta( i ).getName();</span>
<span class="nc bnc" id="L173" title="All 2 branches missed.">      if ( fieldName.equals( name ) ) {</span>
<span class="nc" id="L174">        return i;</span>
      }
    }
<span class="nc" id="L177">    return null;</span>
  }

  /**
   * @param rowMeta
   *          The metadata for the row to be indexed
   * @param row
   *          The data for the row to be indexed
   */

  private boolean indexRow( RowMetaInterface rowMeta, Object[] row ) throws KettleStepException {
    try {

<span class="nc" id="L190">      String id = null;</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">      if ( idFieldIndex == null ) {</span>
<span class="nc" id="L192">        throw new KettleStepException(&quot;ID field must be set&quot; );</span>
      }
<span class="nc" id="L194">      id = &quot;&quot; + row[idFieldIndex]; // &quot;&quot; just in case field isn't string</span>

<span class="nc" id="L196">      IndexRequest req = new IndexRequest(index, type, id);</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">      if ( isJsonInsert ) {</span>
<span class="nc" id="L198">        addSourceFromJsonString( row, req );</span>
      } else {
<span class="nc" id="L200">        addSourceFromRowFields( req, rowMeta, row );</span>
      }
<span class="nc" id="L202">      currentRequest.add(req);</span>




<span class="nc bnc" id="L207" title="All 2 branches missed.">      if ( currentRequest.numberOfActions() &gt;= batchSize ) {</span>
<span class="nc" id="L208">        return processBatch( true );</span>
      } else {
<span class="nc" id="L210">        return true;</span>
      }

<span class="nc" id="L213">    } catch ( KettleStepException e ) {</span>
<span class="nc" id="L214">      throw e;</span>
<span class="nc" id="L215">    } catch ( Exception e ) {</span>
<span class="nc" id="L216">      throw new KettleStepException( BaseMessages.getString( PKG, &quot;ElasticSearchBulk.Log.Exception&quot;, e</span>
<span class="nc" id="L217">          .getLocalizedMessage() ), e );</span>
    }
  }

  /**
   * @param row
   * @param requestBuilder
   */
  private void addSourceFromJsonString( Object[] row, IndexRequest requestBuilder ) throws KettleStepException {
<span class="nc" id="L226">    Object jsonString = row[jsonFieldIdx];</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">    if ( jsonString instanceof byte[] ) {</span>
<span class="nc" id="L228">      requestBuilder.source( (byte[]) jsonString,  XContentType.JSON);</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">    } else if ( jsonString instanceof String ) {</span>
<span class="nc" id="L230">      requestBuilder.source((String) jsonString ,  XContentType.JSON);</span>
    } else {
<span class="nc" id="L232">      throw new KettleStepException( BaseMessages.getString( &quot;ElasticSearchBulk.Error.NoJsonFieldFormat&quot; ) );</span>
    }
<span class="nc" id="L234">  }</span>

  /**
   * @param requestBuilder
   * @param rowMeta
   * @param row
   * @throws IOException
   */
  private void addSourceFromRowFields( IndexRequest requestBuilder, RowMetaInterface rowMeta, Object[] row ) {
<span class="nc" id="L243">    Map&lt;String, Object&gt; jsonMap = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">    for ( int i = 0; i &lt; rowMeta.size(); i++ ) {</span>
<span class="nc bnc" id="L245" title="All 4 branches missed.">      if ( idFieldIndex != null &amp;&amp; i == idFieldIndex ) { // skip id</span>
<span class="nc" id="L246">        continue;</span>
      }

<span class="nc" id="L249">      ValueMetaInterface valueMeta = rowMeta.getValueMeta( i );</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">      String name = hasFields ? columnsToJson.get( valueMeta.getName() ) : valueMeta.getName();</span>
<span class="nc" id="L251">      Object value = row[i];</span>
<span class="nc bnc" id="L252" title="All 4 branches missed.">      if ( value instanceof Date &amp;&amp; value.getClass() != Date.class ) {</span>
<span class="nc" id="L253">        Date subDate = (Date) value;</span>
        // create a genuine Date object, or jsonBuilder will not recognize it
<span class="nc" id="L255">        value = new Date( subDate.getTime() );</span>
      }
<span class="nc bnc" id="L257" title="All 2 branches missed.">      if ( StringUtils.isNotBlank( name ) ) {</span>
<span class="nc" id="L258">        jsonMap.put( name, value );</span>
      }
    }
<span class="nc" id="L261">    requestBuilder.source( jsonMap );</span>
<span class="nc" id="L262">  }</span>

  public boolean init( StepMetaInterface smi, StepDataInterface sdi ) {
<span class="nc" id="L265">    meta = (ElasticSearchBulkMeta) smi;</span>
<span class="nc" id="L266">    data = (ElasticSearchBulkData) sdi;</span>

<span class="nc bnc" id="L268" title="All 2 branches missed.">    if ( super.init( smi, sdi ) ) {</span>
      try {
<span class="nc" id="L270">        numberOfErrors = 0;</span>
<span class="nc" id="L271">        initFromMeta();</span>
<span class="nc" id="L272">        return true;</span>
<span class="nc" id="L273">      } catch ( Exception e ) {</span>
<span class="nc" id="L274">        logError( BaseMessages.getString( PKG, &quot;ElasticSearchBulk.Log.ErrorOccurredDuringStepInitialize&quot; )</span>
<span class="nc" id="L275">            + e.getMessage() );</span>
      }
<span class="nc" id="L277">      return true;</span>
    }
<span class="nc" id="L279">    return false;</span>
  }

  private void initFromMeta() {
<span class="nc" id="L283">    index = environmentSubstitute( meta.getIndex() );</span>
<span class="nc" id="L284">    type = environmentSubstitute( meta.getType() );</span>
<span class="nc" id="L285">    batchSize = meta.getBatchSizeInt( this );</span>
    try {
<span class="nc" id="L287">      timeout = Long.parseLong( environmentSubstitute( meta.getTimeOut() ) );</span>
<span class="nc" id="L288">    } catch ( NumberFormatException e ) {</span>
<span class="nc" id="L289">      timeout = null;</span>
<span class="nc" id="L290">    }</span>
<span class="nc" id="L291">    timeoutUnit = meta.getTimeoutUnit();</span>
<span class="nc" id="L292">    isJsonInsert = meta.isJsonInsert();</span>
<span class="nc" id="L293">    useOutput = meta.isUseOutput();</span>
<span class="nc" id="L294">    stopOnError = meta.isStopOnError();</span>

<span class="nc" id="L296">    columnsToJson = meta.getFieldsMap();</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">    this.hasFields = columnsToJson.size() &gt; 0;</span>


<span class="nc" id="L300">    List&lt;ElasticSearchBulkMeta.Server&gt; servers = meta.getServers();</span>
<span class="nc" id="L301">    HttpHost[] hosts = new HttpHost[servers.size()];</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">    for ( int i=0; i&lt;hosts.length; i++ ) {</span>
      //showMessage(BaseMessages.getString( PKG, &quot;ElasticSearchBulkDialog.Test.TestOKTitle&quot; ));
<span class="nc" id="L304">      hosts[i] = new HttpHost(servers.get(i).getAddr().getHostName(), servers.get(i).getAddr().getPort());</span>
    }
<span class="nc" id="L306">    client = new RestHighLevelClient(RestClient.builder(hosts));</span>

<span class="nc" id="L308">  }</span>

  private boolean processBatch( boolean makeNew ) {
<span class="nc" id="L311">    boolean responseOk = false;</span>

    try {

<span class="nc" id="L315">      BulkResponse response = client.bulk(currentRequest);</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">      if(response.hasFailures()){</span>
<span class="nc" id="L317">        logError( response.buildFailureMessage() );</span>
      }else{
<span class="nc" id="L319">        responseOk = true;</span>
      }
/*
      if ( timeout != null &amp;&amp; timeoutUnit != null ) {
        response = actionFuture.actionGet( timeout, timeoutUnit );
      } else {
        response = actionFuture.actionGet();
      }
  */
<span class="nc" id="L328">    } catch (IOException e) {</span>
<span class="nc" id="L329">      logError( e.getLocalizedMessage() );</span>
<span class="nc" id="L330">    }</span>



<span class="nc bnc" id="L334" title="All 2 branches missed.">    if ( makeNew ) {</span>
<span class="nc" id="L335">      currentRequest = new BulkRequest() ;</span>
<span class="nc" id="L336">      data.nextBufferRowIdx = 0;</span>
<span class="nc" id="L337">      data.inputRowBuffer = new Object[batchSize][];</span>
    } else {
<span class="nc" id="L339">      currentRequest = null;</span>
<span class="nc" id="L340">      data.inputRowBuffer = null;</span>
    }
<span class="nc" id="L342">    return responseOk;</span>
  }


  private void disposeClient() {

<span class="nc bnc" id="L348" title="All 2 branches missed.">    if ( client != null ) {</span>
      try {
<span class="nc" id="L350">        client.close();</span>
<span class="nc" id="L351">      } catch (IOException e) {</span>
<span class="nc" id="L352">        e.printStackTrace();</span>
<span class="nc" id="L353">      }</span>
    }
<span class="nc" id="L355">  }</span>

  public void dispose( StepMetaInterface smi, StepDataInterface sdi ) {
<span class="nc" id="L358">    meta = (ElasticSearchBulkMeta) smi;</span>
<span class="nc" id="L359">    data = (ElasticSearchBulkData) sdi;</span>
    try {
<span class="nc" id="L361">      disposeClient();</span>
<span class="nc" id="L362">    } catch ( Exception e ) {</span>
<span class="nc" id="L363">      logError( e.getLocalizedMessage(), e );</span>
<span class="nc" id="L364">    }</span>
<span class="nc" id="L365">    super.dispose( smi, sdi );</span>
<span class="nc" id="L366">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>